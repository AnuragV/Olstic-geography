<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordlock - Word Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --success-color: #22c55e;
            --background-color: #f8fafc;
            --surface-color: #ffffff;
            --text-color: #1e293b;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--surface-color);
            border-radius: 12px;
            box-shadow: var(--shadow);
        }

        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: var(--surface-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .difficulty-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .difficulty-btn:hover {
            border-color: var(--primary-color);
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--surface-color);
            border-radius: 12px;
            box-shadow: var(--shadow);
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-color);
        }

        .word-display {
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            color: var(--primary-color);
        }

        .game-board {
            position: relative;
            background: var(--surface-color);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .grid-container {
            position: relative;
            z-index: 2;
        }

        .grid {
            display: inline-grid;
            gap: 2px;
            padding: 20px;
            background: #f1f5f9;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            position: relative;
        }

        .grid-4x4 { grid-template-columns: repeat(4, 1fr); }
        .grid-5x5 { grid-template-columns: repeat(5, 1fr); }
        .grid-6x6 { grid-template-columns: repeat(6, 1fr); }

        .cell {
            width: 60px;
            height: 60px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            background: var(--surface-color);
            position: relative;
        }

        .cell.letter {
            background: #e0f2fe;
            color: var(--primary-color);
            border-color: var(--primary-color);
            z-index: 10;
        }

        .cell.filled {
            background: #22c55e;
            color: white;
            border-color: #22c55e;
        }

        .cell.current-target {
            background: #fbbf24;
            color: white;
            border-color: #f59e0b;
            animation: pulse 1s infinite;
        }

        .wall-top { border-top: 4px solid #374151; }
        .wall-right { border-right: 4px solid #374151; }
        .wall-bottom { border-bottom: 4px solid #374151; }
        .wall-left { border-left: 4px solid #374151; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .path-line {
            position: absolute;
            background: #22c55e;
            z-index: 5;
            border-radius: 2px;
        }

        .game-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn--primary {
            background: var(--primary-color);
            color: white;
        }

        .btn--primary:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }

        .btn--secondary {
            background: var(--secondary-color);
            color: white;
        }

        .btn--outline {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn--outline:hover {
            background: var(--primary-color);
            color: white;
        }

        .btn--sm {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: var(--surface-color);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .modal-body {
            margin-bottom: 25px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .instructions-list {
            list-style: none;
            padding: 0;
        }

        .instructions-list li {
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .instructions-list li:before {
            content: "‚Üí ";
            color: var(--primary-color);
            font-weight: bold;
        }

        .modal-footer {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .leaderboard {
            max-height: 300px;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }

        .win-time {
            font-size: 2rem;
            font-weight: bold;
            color: var(--success-color);
            margin: 15px 0;
            text-align: center;
        }

        @media (max-width: 768px) {
            .cell {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            .difficulty-buttons {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Header -->
        <header class="game-header">
            <div class="difficulty-buttons">
                <button class="difficulty-btn active" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>
            <h1 class="game-title">Wordlock</h1>
            <div class="header-right">
                <button class="btn btn--outline btn--sm" id="instructionsBtn">?</button>
            </div>
        </header>

        <!-- Game Stats -->
        <div class="game-stats">
            <div class="stat-item">
                <span class="stat-label">Player:</span>
                <span class="stat-value" id="playerName">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Time:</span>
                <span class="stat-value" id="timer">00:00</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Scrambled:</span>
                <span class="stat-value word-display" id="wordDisplay">????</span>
            </div>
        </div>

        <!-- Game Board -->
        <div class="game-board" id="gameBoard">
            <div class="grid-container" id="gridContainer">
                <!-- Grid cells will be generated by JavaScript -->
            </div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button class="btn btn--primary" id="replayBtn">New Game</button>
            <button class="btn btn--secondary" id="leaderboardBtn">Leaderboard</button>
            <button class="btn btn--outline" id="resetPathBtn">Reset Path</button>
        </div>
    </div>

    <!-- Username Modal -->
    <div class="modal" id="usernameModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Welcome to Wordlock!</h2>
                <p>Enter your username to start playing</p>
            </div>
            <div class="modal-body">
                <form id="usernameForm">
                    <div class="form-group">
                        <label for="usernameInput" class="form-label">Username:</label>
                        <input type="text" id="usernameInput" class="form-input" placeholder="Enter your name" maxlength="20" required>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" form="usernameForm" class="btn btn--primary">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div class="modal hidden" id="instructionsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">How to Play Wordlock</h2>
            </div>
            <div class="modal-body">
                <ul class="instructions-list">
                    <li>Look at the scrambled letters and figure out what word they spell</li>
                    <li>Drag to create a path that connects all letters in the correct word order</li>
                    <li>Your path must fill ALL cells on the grid (like in Zip)</li>
                    <li>Walls block paths between cells but all cells remain navigable</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn--primary" id="closeInstructionsBtn">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal hidden" id="winModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üéâ Congratulations!</h2>
            </div>
            <div class="modal-body">
                <div>
                    <p>You solved the puzzle in:</p>
                    <div class="win-time" id="winTime">00:00</div>
                    <p>Great job! üéä</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn--secondary" id="closeWinBtn">Close</button>
                <button class="btn btn--primary" id="playAgainBtn">Play Again</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="modal hidden" id="leaderboardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üèÜ Leaderboard</h2>
            </div>
            <div class="modal-body">
                <div class="leaderboard" id="leaderboardList">
                    <p style="text-align: center; color: var(--text-muted);">No scores yet. Play a game to see your time!</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn--primary" id="closeLeaderboardBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Game data and configuration
        const WORD_LISTS = {
            easy: ["HOUSE", "PLANT", "MUSIC", "DANCE", "HAPPY", "WORLD", "LIGHT", "BEACH", "PHONE", "SMILE"],
            medium: ["KITCHEN", "JOURNEY", "MORNING", "RAINBOW", "PICTURE", "ELEPHANT", "MOUNTAIN", "COMPUTER"],
            hard: ["ADVENTURE", "BEAUTIFUL", "CHOCOLATE", "BUTTERFLY", "TELEPHONE", "WONDERFUL", "DIFFERENT", "IMPORTANT"]
        };

        const GAME_SETTINGS = {
            easy: { gridSize: 4 },
            medium: { gridSize: 5 },
            hard: { gridSize: 6 }
        };

        // Game state
        let gameState = {
            difficulty: 'easy',
            currentWord: '',
            targetWord: '',
            grid: [],
            letterPositions: new Map(),
            path: [],
            walls: new Set(),
            isDragging: false,
            startTime: null,
            timerInterval: null,
            playerName: '',
            gameStarted: false,
            currentLetterIndex: 0
        };

        // Initialize game
        document.addEventListener('DOMContentLoaded', function() {
            initGame();
        });

        function initGame() {
            setupEventListeners();
            showUsernameModal();
        }

        function setupEventListeners() {
            // Username form
            document.getElementById('usernameForm').addEventListener('submit', function(e) {
                e.preventDefault();
                handleUsernameSubmit();
            });

            // Difficulty buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    gameState.difficulty = this.dataset.difficulty;
                    if (gameState.gameStarted) startNewGame();
                });
            });

            // Control buttons
            document.getElementById('instructionsBtn').addEventListener('click', showInstructionsModal);
            document.getElementById('closeInstructionsBtn').addEventListener('click', hideInstructionsModal);
            document.getElementById('replayBtn').addEventListener('click', startNewGame);
            document.getElementById('resetPathBtn').addEventListener('click', resetPath);
            document.getElementById('leaderboardBtn').addEventListener('click', showLeaderboardModal);
            document.getElementById('closeLeaderboardBtn').addEventListener('click', hideLeaderboardModal);
            
            // Win modal
            document.getElementById('closeWinBtn').addEventListener('click', hideWinModal);
            document.getElementById('playAgainBtn').addEventListener('click', function() {
                hideWinModal();
                startNewGame();
            });
        }

        function showUsernameModal() {
            document.getElementById('usernameModal').classList.remove('hidden');
            document.getElementById('usernameInput').focus();
        }

        function hideUsernameModal() {
            document.getElementById('usernameModal').classList.add('hidden');
        }

        function handleUsernameSubmit() {
            const name = document.getElementById('usernameInput').value.trim();
            if (name) {
                gameState.playerName = name;
                document.getElementById('playerName').textContent = name;
                hideUsernameModal();
                startNewGame();
            }
        }

        function showInstructionsModal() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        function hideInstructionsModal() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        function showWinModal(time) {
            document.getElementById('winTime').textContent = time;
            document.getElementById('winModal').classList.remove('hidden');
        }

        function hideWinModal() {
            document.getElementById('winModal').classList.add('hidden');
        }

        function showLeaderboardModal() {
            updateLeaderboardDisplay();
            document.getElementById('leaderboardModal').classList.remove('hidden');
        }

        function hideLeaderboardModal() {
            document.getElementById('leaderboardModal').classList.add('hidden');
        }

        function startNewGame() {
            gameState.gameStarted = true;
            resetGame();
            generateGrid();
            startTimer();
        }

        function resetGame() {
            gameState.path = [];
            gameState.currentLetterIndex = 0;
            gameState.isDragging = false;
            
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            gameState.startTime = null;
            document.getElementById('timer').textContent = '00:00';
        }

        function resetPath() {
            gameState.path = [];
            gameState.currentLetterIndex = 0;
            gameState.isDragging = false;
            updateGridDisplay();
        }

        function generateGrid() {
            const settings = GAME_SETTINGS[gameState.difficulty];
            const gridSize = settings.gridSize;
            const wordList = WORD_LISTS[gameState.difficulty];
            
            // Select random word
            gameState.targetWord = wordList[Math.floor(Math.random() * wordList.length)];
            gameState.currentWord = scrambleWord(gameState.targetWord);
            
            document.getElementById('wordDisplay').textContent = gameState.currentWord;
            
            // Initialize grid
            gameState.grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
            gameState.letterPositions.clear();
            
            // Place letters randomly
            const letters = gameState.targetWord.split('');
            const positions = [];
            
            // Generate all possible positions
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    positions.push({row, col});
                }
            }
            
            // Shuffle and take needed positions
            shuffleArray(positions);
            
            for (let i = 0; i < letters.length; i++) {
                const pos = positions[i];
                gameState.grid[pos.row][pos.col] = letters[i];
                gameState.letterPositions.set(letters[i] + '_' + i, pos);
            }
            
            // Generate walls
            generateWalls(gridSize);
            
            // Create DOM elements
            createGridDOM(gridSize);
        }

        function scrambleWord(word) {
            const letters = word.split('');
            shuffleArray(letters);
            return letters.join('');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateWalls(gridSize) {
            gameState.walls.clear();
            const numWalls = Math.floor(gridSize * gridSize * 0.15); // 15% of total possible walls
            
            for (let i = 0; i < numWalls; i++) {
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                const direction = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                
                // Check if wall would be valid (not sealing off areas)
                const wallKey = `${row}_${col}_${direction}`;
                gameState.walls.add(wallKey);
            }
        }

        function createGridDOM(gridSize) {
            const gridContainer = document.getElementById('gridContainer');
            gridContainer.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = `grid grid-${gridSize}x${gridSize}`;
            grid.id = 'gameGrid';
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const cellValue = gameState.grid[row][col];
                    if (cellValue) {
                        cell.textContent = cellValue;
                        cell.classList.add('letter');
                    }
                    
                    // Add wall classes
                    for (let dir = 0; dir < 4; dir++) {
                        const wallKey = `${row}_${col}_${dir}`;
                        if (gameState.walls.has(wallKey)) {
                            const wallClasses = ['wall-top', 'wall-right', 'wall-bottom', 'wall-left'];
                            cell.classList.add(wallClasses[dir]);
                        }
                    }
                    
                    // Add event listeners
                    cell.addEventListener('mousedown', (e) => startDrag(row, col, e));
                    cell.addEventListener('mouseenter', (e) => continueDrag(row, col, e));
                    cell.addEventListener('mouseup', (e) => endDrag(row, col, e));
                    
                    // Touch events for mobile
                    cell.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        startDrag(row, col, e);
                    });
                    
                    cell.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.classList.contains('cell')) {
                            const touchRow = parseInt(element.dataset.row);
                            const touchCol = parseInt(element.dataset.col);
                            continueDrag(touchRow, touchCol, e);
                        }
                    });
                    
                    cell.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        endDrag(row, col, e);
                    });
                    
                    grid.appendChild(cell);
                }
            }
            
            gridContainer.appendChild(grid);
            updateGridDisplay();
        }

        function startDrag(row, col, e) {
            e.preventDefault();
            gameState.isDragging = true;
            gameState.path = [{row, col}];
            updateGridDisplay();
        }

        function continueDrag(row, col, e) {
            if (!gameState.isDragging) return;
            
            const lastCell = gameState.path[gameState.path.length - 1];
            if (!lastCell) return;
            
            // Check if adjacent and not blocked by wall
            if (isAdjacent(lastCell.row, lastCell.col, row, col) && 
                !isWallBlocking(lastCell.row, lastCell.col, row, col)) {
                
                // Don't add if already in path (except going back one step)
                if (gameState.path.length > 1 && 
                    gameState.path[gameState.path.length - 2].row === row && 
                    gameState.path[gameState.path.length - 2].col === col) {
                    // Going back one step - remove last cell
                    gameState.path.pop();
                } else if (!gameState.path.some(cell => cell.row === row && cell.col === col)) {
                    // Add new cell to path
                    gameState.path.push({row, col});
                }
                
                updateGridDisplay();
            }
        }

        function endDrag(row, col, e) {
            gameState.isDragging = false;
            checkWinCondition();
        }

        function isAdjacent(row1, col1, row2, col2) {
            const rowDiff = Math.abs(row1 - row2);
            const colDiff = Math.abs(col1 - col2);
            return (rowDiff <= 1 && colDiff <= 1) && !(rowDiff === 0 && colDiff === 0);
        }

        function isWallBlocking(row1, col1, row2, col2) {
            // Check for walls that would block this movement
            if (row2 === row1 - 1) { // Moving up
                return gameState.walls.has(`${row1}_${col1}_0`) || gameState.walls.has(`${row2}_${col2}_2`);
            }
            if (col2 === col1 + 1) { // Moving right
                return gameState.walls.has(`${row1}_${col1}_1`) || gameState.walls.has(`${row2}_${col2}_3`);
            }
            if (row2 === row1 + 1) { // Moving down
                return gameState.walls.has(`${row1}_${col1}_2`) || gameState.walls.has(`${row2}_${col2}_0`);
            }
            if (col2 === col1 - 1) { // Moving left
                return gameState.walls.has(`${row1}_${col1}_3`) || gameState.walls.has(`${row2}_${col2}_1`);
            }
            return false;
        }

        function updateGridDisplay() {
            const gridSize = GAME_SETTINGS[gameState.difficulty].gridSize;
            
            // Clear all cell states
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.remove('filled', 'current-target');
                    }
                }
            }
            
            // Mark cells in path as filled
            gameState.path.forEach(({row, col}) => {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.classList.add('filled');
                }
            });
            
            // Highlight next target letter
            const nextLetter = getNextTargetLetter();
            if (nextLetter) {
                gameState.letterPositions.forEach((pos, key) => {
                    if (key.startsWith(nextLetter + '_')) {
                        const cell = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
                        if (cell && !cell.classList.contains('filled')) {
                            cell.classList.add('current-target');
                        }
                    }
                });
            }
        }

        function getNextTargetLetter() {
            const pathLetters = gameState.path
                .map(({row, col}) => gameState.grid[row][col])
                .filter(letter => letter !== null);
            
            const targetSequence = gameState.targetWord.split('');
            return targetSequence[pathLetters.length] || null;
        }

        function checkWinCondition() {
            const gridSize = GAME_SETTINGS[gameState.difficulty].gridSize;
            const totalCells = gridSize * gridSize;
            
            // Check if path fills all cells
            if (gameState.path.length !== totalCells) return false;
            
            // Check if letters are in correct order
            const pathLetters = gameState.path
                .map(({row, col}) => gameState.grid[row][col])
                .filter(letter => letter !== null)
                .join('');
            
            if (pathLetters === gameState.targetWord) {
                handleWin();
                return true;
            }
            
            return false;
        }

        function handleWin() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            const finalTime = document.getElementById('timer').textContent;
            saveScore(gameState.playerName, finalTime, gameState.difficulty);
            setTimeout(() => showWinModal(finalTime), 300);
        }

        function startTimer() {
            gameState.startTime = Date.now();
            gameState.timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (!gameState.startTime) return;
            
            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function saveScore(playerName, time, difficulty) {
            const scores = getLeaderboard();
            scores.push({
                name: playerName,
                time: time,
                difficulty: difficulty,
                timestamp: Date.now(),
                timeInSeconds: timeToSeconds(time)
            });
            
            scores.sort((a, b) => a.timeInSeconds - b.timeInSeconds);
            localStorage.setItem('wordlock_leaderboard', JSON.stringify(scores.slice(0, 10)));
        }

        function getLeaderboard() {
            const saved = localStorage.getItem('wordlock_leaderboard');
            return saved ? JSON.parse(saved) : [];
        }

        function timeToSeconds(timeString) {
            const [minutes, seconds] = timeString.split(':').map(Number);
            return minutes * 60 + seconds;
        }

        function updateLeaderboardDisplay() {
            const scores = getLeaderboard();
            const leaderboardList = document.getElementById('leaderboardList');
            
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No scores yet!</p>';
                return;
            }
            
            leaderboardList.innerHTML = scores.map((score, index) => `
                <div class="leaderboard-entry">
                    <span>#${index + 1} ${score.name}</span>
                    <span>${score.time} (${score.difficulty})</span>
                </div>
            `).join('');
        }
    </script>
</body>
</html>
